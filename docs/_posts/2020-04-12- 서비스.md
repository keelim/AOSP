# 안드로이드 서비스

안드로이드는 시스템의 안정성  위하여 하드웨어 제어 등의 기능  다음과 같이 두 부분으로 분리
● Server: Service(하드웨어제어 등)  제공하는 부분
● Client: 하드웨어에 접근하기 위해 Server에 요청한다. (상호간 양방향 통신도 가능하다.)

## 서비스 개발

핵심 서비스는 일반적으로 별도의 프로세스에서 실행. IBinder 인터페이스 제공 해야  즉, 바인터 클래스인 IBinder  사용하여 프로세스간에 통신. 또한 원활한 서비스 제공  위해 쓰레드  유지할 필요 핵심 서비스  사용하기 전에 Binder Driver에 추가. Binder Driver  위하여 Service Manager에서 핵심 서비스  추가. 또한, Binder Driver에서 Service Manager가 서비스  받  수 있다.

서비스의 구현
서비스  ServiceManager에 등록 트랜잭션  처리해주는 서비스  만듬.
다음 [그림1]과 같이 ServiceManager에 등록한 서비스가 추가된다. [리스트1] 소스에서는 단지 AddService 추가 작업. AddService는 Binder Driver에 추가될 핵심 서비스. C++  사용 AddService 클래스 정의 제공.

```cpp

#include <sys/types.h>
#include <unistd.h>
#include <grp.h>

#include <binder/IPCThreadState.h>
#include <binder/ProcessState.h>
#include <binder/IServiceManager.h>
#include <utils/Log.h>

#include <private/android_filesystem_config.h>

#include "../core_service/addservice.h"
using namespace android;

int main (int argc, char ** argv)
{
sp <ProcessState> proc(ProcessState::self());
sp <IServiceManager> sm = defaultServiceManager ();
LOGE ( "ServiceManager : %p", sm.get());
AddService::instantiate();
ProcessState::self()->startThreadPool();
IPCThreadState::self()->joinThreadPool();
}

```

서비스 등록 예제

## 클라이언트의 구현

등록되어 있는 서비스에 접근하여 데이터  주고 받는다. setN() 메서드는 ServiceManager 인터페이스  얻기 위하여 getAddService ()  호출. ServiceManager 인터페이스  사용하여 AddService 서비스  할당해 Service Manager 묶기에 성공하면 ServiceManager는 BpBinder의 IBinder 인터페이스  제공한다. 인터페이스 참조 binder 변수에 저장.

```cpp

// AddService.h
#ifndef ANDROID_GUILH_ADD_SERVICE_H
#define ANDROID_GUILH_ADD_SERVICE_H
#include <utils/RefBase.h>
#include <binder/IInterface.h>
#include <binder/Parcel.h>

namespace android {
class AddService : public BBinder
{
public:
static int instantiate();
AddService();
virtual ~AddService();
virtual status_t onTransact(uint32_t, const Parcel&, Parcel*, uint32_t);
};
}; //namespace
#endif

```

```cpp

// AddService.cpp
#include "addservice.h"
#include <binder/IServiceManager.h>
#include <binder/IPCThreadState.h>

namespace android
{
static struct sigaction oldact;
static pthread_key_t sigbuskey;

int AddService::instantiate()
{
LOGE("AddService instantiate");
int r = defaultServiceManager()->addService( String16("jhc.add1"), new AddService() );
LOGE("AddService r = %dn", r);
return r;
}

AddService::AddService()
{
LOGE("AddService created");
pthread_key_create(&sigbuskey, NULL);
}

AddService::~AddService()
{
pthread_key_delete(sigbuskey);
LOGE("AddService destroyed");
}

status_t AddService::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
switch(code) {
case 0:
{
pid_t pid = data.readInt32();
int num = data.readInt32();
num = num + 1000;
LOGE("server : num = %d",num);
reply->writeInt32(num);
return NO_ERROR;
} break;
default:
return BBinder::onTransact(code, data, reply, flags);
}
}
}; //namespace

```

```cpp

#include <binder/IServiceManager.h>
#include <binder/IPCThreadState.h>
#include <utils/Log.h>
#include "ADD.h"

namespace android {
sp<IBinder> binder;
void Add::setN(int n)
{
getAddService();
Parcel data, reply;
data.writeInt32(getpid());
data.writeInt32(n);
LOGE("BpAddService::create remote()->transact()n");
binder->transact(0, data, &reply);
return;
}

const void Add::getAddService()
{
sp<IServiceManager> sm = defaultServiceManager();
binder = sm->getService(String16("jhc.add1"));
LOGE("Add::getAddService %pn",sm.get());
if (binder == 0)
{
LOGW("AddService not published, waiting...");
return;
}
}
}; //namespace

```

Binder 클래스
바인더에 관련된 전체 클래스의 구조는 
![그림3](http://oss.kr/oss/images/news/000000005626-0003.jpg)

메모리 관련 소스들
바인더와 연동이 되는 여러 개의 메모리 관련 클래스들이 존재. IMemory.h-IMemoryHeap과 BnMe moryHeap class와 관련된 메모리 인터페이스에 대한 정의와 일반적인 메모리 class인 IMemory와 BnMemory에 대한 내용이 있다.

● MemoryHeapBase.h-BnMemoryHeap으로부터 상속된 MemoryHeap에 대한 정의
● MemoryBase.h-BnMemory로부터 상속된 Memory Base에 대한 정의

일반적으로 프로세스에 있어 힙 메모리(eap memory)  사용하는 것은 MemoryHeapBase 사용에 대한 것  기본으로 한다(malloc과 같은). 이와는 대조적으로 MemoryBase는 하나의 메모리로부터 이미 할당된 힙 메모리  사용한다. 이외에 메모리 관련 함수들은 MemoryDealer.h와 Memory HeapPmem.h에 정의되어 있다.

바인더의 RPC 구조
● IInterface.h - Binder Interface관련 템플릿이 지정된 header
● BnInterface
● BpInterface
● BnInterface 템플릿
● Native Interface작성시 사용
● 바인더의 서버파트 코드에서 사용됨
● BpInterface 템플릿
● Proxy Interface 작성시 사용
● 바인더의 클라이언트 파트 코드에서 사용됨

사실상 두 템플릿이 사용 될 때는 템플릿으로부터 상속받아서 새로운 클래스  생성하여 사용하게 되고, 각각 서로 각 프로세스의 다른 편 접속 창구의 역할  하게 된다.

```cpp

template<typename INTERFACE>
class BnInterface : public INTERFACE, public BBinder
{
public:
virtual sp<IInterface> queryLocalInterface(const String16& _descriptor);
virtual String16 getInterfaceDescriptor() const;
protected:
virtual IBinder* onAsBinder();
};
template<typename INTERFACE>
class BpInterface : public INTERFACE, public BpRefBase
{
public:
BpInterface(const sp<IBinder>& remote);
protected:
virtual IBinder* onAsBinder();
};

```

Binder 사용 Interface선언
사용자 정의 Binder interface인 Bp로 시작되는 Class  만들 때 INTERFACE에서 상속된 두 템플 BnInterface와 BpInterface  사용한다. BpInterface  이용해서 Proxy Class  선언할 경우는 일반적인 방법으로 선언하지 않고 매크로  이용해서 선언.

BpXXX Interface선언 방법
● DECLARE_META_INTERFACE
● IMPLEMENT_META_INTERFACE
● 위의 두 개의 macro  이용해서 선언

BnInterface  이용해서 Native Class  선언할 경우는 BnXXX의 형태로 직접 선언. 그러므로, Binder관련 IPC에 대한 코드  분석할 경우는 BpXXX의 인터페이스는 관련 Macro  조사.
사용자 정의 proxy interface인 BpXXX  정의할 때는 두 개의 매크로  이용해서 선언.

```cpp

define DECLARE_META_INTERFACE(INTERFACE) ￦
static const String16 descriptor; ￦
static sp<I##INTERFACE> asInterface(const sp<IBinder>& obj); ￦
virtual String16 getInterfaceDescriptor() const; ￦
#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME) ￦
const String16 I##INTERFACE::descriptor(NAME); ￦
String16 I##INTERFACE::getInterfaceDescriptor() const { ￦
return I##INTERFACE::descriptor; ￦
} ￦
sp<I##INTERFACE> I##INTERFACE::asInterface(const sp<IBinder>& obj) ￦
{
... ￦
return intr; ￦
}

```

BpInterface는 위의 매크로에서 볼 수 있듯이 asInterfa ce()와 getInterfaceDescriptor()함수만 설정함으로써 만들어질 수 있다.

바인더의 기본 동작


[그림 4]

바인더  동작시키기 위해서는 앞에서 설명한 libbinder .so, service manager 등  이용. service manager는 프로세서 커뮤니케이션이 필요한 두 개의 프로세스에 서비스  시작하게 해주는 복잡한 데몬 프로세스(daemon process). 두 개의 프로세스는 libbinder.so   호출함으로써 통신이 이루어지며, 실제 통신에서는 커널 스페이스의 공유 메모리 영역  사용


● Native local - BnABC, 이 클래스  실제로 구현하기 위해서는 상속받는 것이 필요.
● Proxy agent- BpABC, 실현되어 있는 인터페이스에 대한 프레임웍이다. 하지만 인터페이스는 클래스  그대로 반영하지는 않는다
● client-실제로 BpABC  호출했  때 client interface ABC가 된다.
● Native함수(local)인 Bn이 맡는 부분 - IServiceManager:: AddService()   이용해서 service  등록해 BnABC::on Transact()  실행한다.
● Proxy함수인 Bp가 맡는 부분- client의 요청  받아서 해당 함수  실행.
BpABC::remote()->transact() 함수  호출(해서 접속함)

● client가 맡는 부분- ABC에 대한 aceess  획득하기 위하여, 인터페이스 함수  호출. 이 함수들은 사실은 Bp ABC  호출. 그리고 나서 BnABC로의 IPC 통신  하게된다. 그리고, client의 동작에 관련된 함수들  호출.
프로세스의 생성이 끝나면 BnABC와 BpABC 인터페이스는 ABC  상속.

● BpABC의 동작(Service user) - BpABC는 일반적인 함수 호출에서와 같이 실행. 구현된 class는 실제 통신에의 응답  반영하도록 작성하지만 실제 함수로는 구현되지 않는다. 즉, 통신개념이기 때문에 실제의 코드 동작은 BnABC쪽에서 이루어진다.

● BnABC의 동작(Server provider)- BnABC는 실제로 맡은 일  수행하는 부분의 코드. 이  위해서 Class상속이 실제로 필요한 인터페이스 클래스, BpABC 요청에 따른 처리  하기 위해 구현된 실제 동작함수들. BpABC의 요청에 따른 응답  reply값으로 돌려준다. return값과 reply값은 다른 개념. return 값은 실제 함수의 return값이다. (BnABC가 BpABC로 돌려주는 경우가 많다). reply 값은 BnABC에서 BpABC로 응답에 대한 답  돌려주는 것이다. 보통은 이 두 개의 값  동일하게 처리.

IServiceManager로부터 service  획득한 client ABC인터페이스는 client interface  호출.
실제 이 호출은 BpABC에 대한 호출. 바인더의 IPC 메커니즘  통해서 BpABC와 BnABC는 통신  하게 되고, BnABC는 실제 특정 타입에 대한 기능  실현 두 개의 프로세스는 서버와 클라이언트의 관계로 실제 단단하게 연결. 이것은 process간의 통신으로 생각할 필요가 없이 client에서 직접적으로 프로세스간의 함수  호출하는 것처럼 보인다. 물론, 이 함수들은 반드시 ABC에 정의되어 있어야 한다.

● IServiceManager 동작- IServiceManager는 IService Manager.h와 IServiceManager.cpp에 해당 코드가 있다. IServiceManager는 ServiceManager daemon으로부터 실행이 되며, 사용자 프로그램은 BpServiceManager  통해서 다른 서비스  요청할 수 있다. IServiceManager.h 에는 다음과 같은 default IServiceMa nager 인터페이스가 정의.

sp<IServiceManager> defaultServiceManager();

실제 구현 예  통한 Binder의 구조 파악
PermissionController-인터페이스 접근제어  담당
libutils에 있는 다음과 같은 두 개의 파일에 정의되어 있음
IPermissionController.h
IPermissionController.cpp
IPermissionController.h- 주요 인터페이스에 대한 정의가 되어 있으며 주로 Binder관련
인터페이스가 정의되어 있음. IInterface로부터 상속받은 Bp 인터페이스인 IPermissionController와 IPermission Controller로부터 상속받은 BnPermissionController에 대한 클래스에 대한 정의가 되어 있음


```cpp
class IPermissionController : public Iinterface {
public:
DECLARE_META_INTERFACE(PermissionController);
virtual bool checkPermission(const String16& permission,
int32_t pid, int32_t uid) = 0;
enum {
CHECK_PERMISSION_TRANSACTION = IBinder::FIRST_ CALL_TRANSACTION }; };
class BnPermissionController : public BnInterface<IPermission Controller> {
public:
virtual status_t onTransact( uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags = 0); };

```

IPermissionController.h
IPermissionController class안의 DECLARE_META_ INTERFACE 매크로의 사용은 Bp쪽 인터페이스  정의.

```cpp

enum {
CHECK_PERMISSION_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION
};

```

위와 같이 선언된 부분은 Bp 인터페이스와 Bn 인터페이스에서 서로 통신에 사용하는 user defined command  나타낸다. IPermissionController class는 순수 virtual 함수의 형태  갖는 checkPermission()만  멤버로 가지고 있다. BnPermissionController 는 BnInterface라는 템플릿으로부터 상속한다. BnPermissionController는 실제로 BBinder와 IPermissionController class로부터 이중으로 상속이 된 것이다.

IPermissionController.cpp
IPermissionController class에 선언된 것 구현. BpPermissionController Binder의 proxy 코드로서 client process에서 호출되는 함수  정의 호출되는 함수는 해당 command와 data  Bn 인터페이스로 binder  통해서 전송한다. IMPLEMENT_META_INTERFACE 매크로  이용하여 인터페이스  생성.

BnPermissionController
BnPermissionController는 IPermissionController로부터 상속되었기 때문에, 순수 virtual 함수인 checkPermi ssion()이 아직 실체화 되지 않은 상태
.
BnPermissionController는 여기서는 초기화 되지 않으며 실제적으로는 인터페이스만 존재하게 된다. 이것은 상속  받  때 실제로 실체화가 되며 특정한 실제 함수로 세팅.

IPermissionController.h에서 선언된 class는 IPermi ssionController.cpp에서 구현.

```cpp

class BpPermissionController : public BpInterface<IPermission Controller> {
public:
BpPermissionController(const sp<IBinder>& impl)
: BpInterface<IPermissionController>(impl) { }
virtual bool checkPermission(const String16& permission, int32_t pid, int32_t uid) {
Parcel data, reply; // data 전송  위한 Parcel class  이용하였음
data.writeInterfaceToken(IPermissionController::getInterfaceDescriptor());
data.writeString16(permission);
data.writeInt32(pid);
data.writeInt32(uid);
remote()->transact(CHECK_PERMISSION_TRANSACTION, data, &reply);
// fail on exception
if (reply.readInt32() != 0) return 0;
return reply.readInt32() != 0; } };
IMPLEMENT_META_INTERFACE(PermissionController, "android.os.IPermissionController");

```

```cpp

status_t BnPermissionController::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
//printf("PermissionController received: "); data.print();
switch(code) {
case CHECK_PERMISSION_TRANSACTION: {
CHECK_INTERFACE(IPermissionController, data, reply);
String16 permission = data.readString16();
int32_t pid = data.readInt32();
int32_t uid = data.readInt32();
//==> server쪽의 실체 함수 호출
bool res = checkPermission(permission, pid, uid);
// write exception
reply->writeInt32(0);
reply->writeInt32(res ? 1 : 0); // 실체함수에서의 return값  return
return NO_ERROR;
} break;
default:
return BBinder::onTransact(code, data, reply, flags); } }

```

Binder서비스의 시작
BnABC 서비스의 시작- 프로세스에 대한 보호처리  끝낸 후에 시작되는 local service는 BnABC 상속에 의해 실제 class가 실체화 됨으로써 제공되게 된다. 서비스의 이름은 일반적으로 ABC 라고 이름  붙이게 된다. 보통 ABC라는 service는 instantiate()라는 함수  포함하고 있으며, 이 함수는 일반적으로 다음과 같은 형태가 된다.

```cpp

void ABC::instantiate() {
defaultServiceManager()->addService(
String16("XXX.ABC"), new ABC ());
}

```

defaultServiceManager()  호출함으로써, "XXX.ABC" services  기존의 서비스들에 추가.

BpABC 접속의 시작
BpABC는 주로 데이터  전송하기 위하여 mRemote->transact()  호출 과정.
mRemote는 BpRefBase 클래스의 멤버이다. 이것이 IBinder이며, 실제 함수가 호출되는 과정의 흐름은 다음과 같다.

```cpp

mRemote () -> transact ()
Process:: self ()
IPCThreadState:: self () -> transact ()
writeTransactionData ()
waitForResponse ()
talkWithDriver ()
ioctl (fd, BINDER_WRITE_READ, & bwr)

```

IPCThreadState:: executeCommand ()함수에서 실제 전송이 이루어진다.
Service Provider(server라고 표현)는 service manager에 등록  해서 서비스 할 수 있는 대기상태로 존재하게 된다. defaultServiceManager()는 다음과 같은 함수들  호출하게 된다.

```cpp

ProcessState::self()->getContextObject(NULL));
IPCThreadState* ipc = IPCThreadState::self();
IPCThreadState::talkWithDriver()

```

ProcessState 클래스는 생성자에서 open_driver()  호출해서 talkWithDriver()  구현한 프로세스에 접근할 수 있는 통로 설정.

---
layout: post
title: "자바 서비스 프레임워크"
date: 2019-05-24 20:00:00
author: Sihyeon Kim
categories: android-framework-study
---

## 자바 서비스 프레임워크

- 자바 기반의 애플리케이션 프레임워크에서 동작하는 자바 시스템 서비스를 개발할 때 이용하는 클래스 집합  
- 자바 서비스 프레임워크는 JNI를 통해 네이티브 서비스 프레임워크를 재사용함으로써 자바 레이어의 서비스 사용자가 자바로 작성된 서비스 뿐만 아니라 C++로 작성된 서비스도 이용.  

- 네이티브 서비스 프레임워크와의 차이점  
  - 서비스 생성
  1) Binder 클래스를 상속받아 개발하는 방식: 서비스를 정밀하게 제어할 때 적절, 자바 시스템 서비스를 개발할 때 사용  
  2) Service 클래스를 상속받아 개발: 특정 작업을 주기적으로 백그라운드에서 수행하는 프로세스를 구현하는 데 사용  
  - 바인더 IPC 처리: 자바 서비스 프레임워크에서는 바인더 IPC를 지원위해 JNI를 통해 연결된 네이티브 서비스 프레임워크의 구성요소 재사용  
  
## 자바 서비스 프레임워크의 계층별 요소

- 서비스 사용자의 서비스 레이어에 매니저 클래스가 위치
- RPC 레이어에 AIDL 도구로 자동 생성된 스텁과 프록시 클래스가 위치  
- IPC 레이어에 위치한 구성요서가 JNI를 통해 네이티브 프레임워크의 구성요소와 연결

- 서비스 레이어  
  - 시스템 서비스 개발자는 애플리케이션 개발자가 시스템 서비스를 이용할 수 있게 SDK에 래퍼 클래스를 포함 

- RPC 레이어  
  - AIDL 언어와 컴파일러를 이용해 서비스 프록시와 서비스 스텁 자동으로 생성
  - AIDL은 안드로이드에서 프로세스 간의 IPC를 통해 상호작용하는 자바 기반의 코드를 작성하는 데 사용되는 인터페이스 정의 언어

- IPC 레이어  
  - 서비스와 서비스 프록시가 상호작용 할 때도 바인더 IPC를 이용
  - 바인더 IPC를 위해 자바 서비스 프레임워크에서는 BinderProxy와 Binder 클래스가 이용
  - 자바 서비스 프레임워크에서는 JNI를 통해 네이티브 서비스 프레임워크의 바인더 IPC를 재사용
  

## 자바 서비스 프레임워크의 클래스별 상호작용

- 자바 서비스를 시스템에 등록하는 과정에서 자바 서비스 프레임워크 구성요소가 상호작용하는 과정

### 1) 서비스 등록 요청(서비스)

자바 서비스 매니저인 ServiceManager 클래스를 이용해 처리한다  
FooService는 ServiceManager의 addService() 메서드를 호출하여 시스템에 등록한다  
ServiceManager 내부에는 BinderProxy가 있다  
BinderProxy는 컨텍스트 매니저를 가리키는 BpBinder와 JNI를 통해 연결  

### 2) 서비스 등록(서비스 매니저)

서비스 프록시는 addService() 메서드의 호출 정보를 RPC 데이터로 변환  
바인더 RPC 데이터는 Parcel 클래스에 저장되어 BinderProxy에 전달되고, JNI를 통해 BpBinder에 전달된다. 바인더 IPC를 통해 컨텍스트 매니저에 전달되어 FooService 서비스가 시스템에 등록

### 3) 서비스 검색 요청(서비스 사용자)

SDK에서 제공하는 getSystemService() 메서드를 호출해서 서비스를 검색  

### 4) 서비스 검색(서비스 매니저)

getSystemService()는 getService() 메서드를 호출. 서비스가 검색되면 서비스 프록시를 참조하는 매니저를 서비스 사용자에게 반환  

### 5) foo() 서비스 프록시 메서드 호출(서비스 사용자)

메서드 호출 정보를 RPC 데이터로 변환한 다음 BpBinder에 전달  

### 6) foo() 서비스 스텁 메서드 실행(서비스)

바인더 RPC 데이터를 전달 받아 Binder의 메서드 호출  
데이터를 분석하여 서비스 스텁 메서드 

## 동작 메커니즘

### 자바 서비스 프레임워크 초기화

- app_process 실행 
-> AndroidRuntime 클래스에서 startReg() 함수 호출
-> JNI 네이티브 함수가 달빅 가상 머신으로 로딩
-> register_android_os_Binder() 함수를 호출해서 JNI 네이티브 함수 등록(자바 서비스 프레임워크와 관련된 네이티브 함수)  

### Binder 클래스의 JNI 설정

- int_register_android_os_Binder() 함수 호출
-> Binder 클래스 정보를 전역 변수인 gBinderOffsets에 저장
-> Binder 클래스의 네이티브 메서드와 JNI 네이티브 함수를 매핑  

### Binder 객체 생성

- Binder 클래스는 바인더 IPC를 위해 BBinder의 기능을 사용하기 때문에 Binder 객체가 생성될 때 BBinder가 함께 생성

### JavaBBinder 객체 생성

- JavaBBinder의 인스턴스는 JavaBBinderHolder의 get() 함수에서 생성
- Binder의 생성자가 호출
-> 네이티브 메서드인 init()이 호출
-> 연결된 JNI 네이티브 함수에 의해 JavaBBinderHolder 객체가 생성
-> init() 메서드를 호출한 Binder 객체의 주소를 인자값으로 받아 mObject 변수에 저장
-> JavaBBinder는 JavaBBinderHolder의 get() 함수를 호출하면 생성
-> JavaBBinder의 생성자는 JavaBBinderHolder의 mObject 변수를 인자로 받아 자신의 mObject 변수에 저장  

### Binder 클래스와 JavaBBinder 서비스 스텁 클래스의 상호작용

- BBinder에서 기본으로 제공하는 바인더 RPC 함수 이외에 새로운 기능을 제공하려면 BBinder를 상속받은 서비스 스텁 클래스에서 onTransact() 메서드를 재정의

### BinderProxy 클래스를 위한 JNI 설정

- int_register_android_os_BinderProxy() 호출
-> BinderProxy 클래스 정보를 gBinderProxyOffsets 전역 변수에 저장
-> BinderProxy 클래스의 네이티브 메서드와 JNI 네이티브 함수를 매핑

### BinderProxy 객체 생성

- BinderProxy 클래스도 바인더 IPC를 수행하기 위해 네이티브 서비스 프레임워크의 BpBinder의 기능을 사용하므로 BinderProxy 객체가 생성될 때 BpBinder 객체가 필요  
- BpBinder 객체는 Parcel의 readStrongBinder() 함수 생성  

### BinderProxy 클래스와 BpBinder 클래스의 상호작용

- BinderProxy의 transact() 네이티브 메서드는 android_os_BinderProxy_transact() JNI 네이티브 함수로 매핑 BinderProxy와 BpBinder가 상호작용할 때 JNI 네이티브 함수가 호출

### Parcel 클래스의 JNI 설정

- Parcel 클래스는 바인더 IPC가 진행되는 동안 송신측에서 수신측으로 전달되는 데이터를 저장하는 데 사용
- Parcel은 내부 버퍼 안에 IBinder 객체 레퍼런스를 가지고 있어 프로세스를 가로질러 이동할 대도 레퍼런스 값을 유지
- int_register_android_os_BinderProxy() 함수 호출
-> Parcel 클래스의 정보를 gParcelOffsets 전역 변수에 저장
-> Parcel 클래스의 네이티브 메서드와 JNI 네이티브 함수를 매핑  

#### Parcel 객체 생성

- Parcel의 생성자는 private으로 선언, new Parcel() 형태로 인스턴스를 생성할 수 없음
- Parcel 인스턴스를 획득하기 위해 Parcel의 obtain() 메서드를 사용  

#### Parcel(Java) 클래스와 Parcel(C++) 클래스 간의 상호작용

- Parcel(Java) 클래스는 서비스 프록시에서 바인더 RPC 데이터를 저장할 때 사용  
- 서비스 프록시에서 바인더 RPC를 진행하면 달빅 가상 머신에서 생성된 Parcel(Java) 객체가 서비스에게 전달되어야 하는데 그러기 위해서는 Parcel(Java) 객체를 Parcel(C++) 객체로 변환

### 자바 시스템 서비스 구현

- 알람 매니저 서비스를 토대로 시스템 서비스의 구조 파악

### 알람 매니저 서비스의 구조 분석

- AlaramManagerService 클래스 계층 구조  
  - 자바 서비스 프레임워크의 구성요소인 IInterface 인터페이스, binder 클래스  
  - IAlarmManager 서비스 인터페이스와 서비스 스텁에서 위 클래스 상속  
  - AIDL을 통해 자동으로 생성된 서비스 스텝 클래스와 서비스 플록시 클래스  
  - AlarmManagerService 클래스와 AlarmManager 래퍼 클래스  
  
### 알람 매니저 서비스 구현 방식

- AIDL을 이용하여 클래스를 자동으로 생성  
- AIDL 컴파일러로 컴파일하면 알람 매니저 서비스의 서비스 인터페이스, 서비스 프록시, 서비스 스텁 클래스가 자동으로 생성  

### 알람 매니저 서비스 사용

- 시스템 서비스를 사용하려면 SDK의 getSystemService() 메서드를 이용
- 알람 매니저 서비스는 Context 클래스의 ALARM_SERVICE 변수를 인자로 getSystemService() 메서드를 호출하면 애플리케이션에서 사용


---
layout: post
title: "자바 시스템 서비스 동작 분석"
date: 2019-05-30 20:00:00
author: Sihyeon Kim
categories: android-framework-study
---

- 자바 시스템 서비스가 안드로이드 프레임워크 내에서 어떻게 동작하는가  
# 액티비티 매니저 서비스  
- 액티비티 매니저 서비스: 자바 시스템 서비스이며, 안드로이드 애플리케이션 컴포넌트(액티비티, 서비스, 브로드캐스트 리시버 등)를 생성하고, 이들의 생명주기를 관리한다  
- 애플리케이션 서비스의 실행을 요청한 애플리케이션 프로세스와 액티비티 매니저 서비스가 어떻게 상호작용하는가  
- Remot Service Controller 예제 애플리케이션: 'Start Service' 버튼을 누르면 Remote Servcie가 시작되는 프로그램  
  - 애플리케이션에서 서비스를 실행하면, 액티비티 매니저 서비스가 애플리케이션에서 요청한 서비스를 실행한다  
- 액티비티 매니저 서비스가 어떻게 RemoteService를 실행할까?  
  - RemoteService는 애플리케이션과 독립된 프로세스에서 동작하는 리모트 애플리케이션 서비스이다. 따라서 서비스를 실행하기 위해서는 우선 새로운 프로세스를 실행해야한다.  
  - 액티비티 매니저 서비스는 Zygote를 이용해 서비스를 실행할 프로세스를 생성한 후, 프로세스 상에서 애플리케이션이 요청한 RemoteService를 실행한다.  
- 구체적인 과정  
(1) startService() API를 통해 서비스 시작 요청(바인더 RPC 이용) ('Start Service'버튼 누르고, ActivityManagerService에게)  
애플리케이션은 startService()나 bindService() API를 통해 애플리케이션 서비스를 생성한다.  
(2) ActivityThread 생성 요청 (Unix Domain Socket 이용) (AcitivityManagerService에서 Zygote로)  
애플리케이션으로부터 startService()를 통해 서비스 실행요청을 받은 액티비티 매니저 서비스는 요청받은 서비스 클래스를 실행하기 위한 ActivityThread 생성요청을 Zygote에게 한다.  
(ActivityThread: 모든 안드로이드 애플리케이션의 메인 스레드, 액티비티 및 서비스의 생성 및 스케줄링을 담당)  
(3) ActivityThread 생성 (Zygote에서 ActivityThread로)  
액티비티 매니저 서비스로부터 ActivityThread 실행을 요청받은 Zygote는 새로운 프로세스를 생성한 다음 그 위에 ActivityThread 클래스를 로딩한다  
(4) RemoteService 생성 요청 (바인더 RPC 이용) (ActivityManagerService에서 ActivityThread로)  
액티비티 매니저 서비스는 ActivityThread에게 RemoteService 서비스의 생성을 요청한다.  
(5) RemoteService 생성  
ActivityThread는 RemoteService를 실행한다.  

# 액티비티 매니저 서비스를 통한 서비스 생성 코드 분석  
- 액티비티 매니저 서비스가 어떻게 애플리케이션 서비스를 생성하는가  
## Controller 액티비티 - startService() 메서드 호출
- 'Start Service' 버튼 -> 이벤트 핸들러 호출 -> intent를 인자로 startService() API 메서드를 호출  
- 안드로이드 애플리케이션 컴포넌트는 인텐트라는 메시지를 통해 활성화된다. 안드로이드에서는 인텐트를 이용해 실행하고자 하는 서비스의 클래스명을 명시적으로 지정해서 원하는 컴포넌트를 실행할 수 있다.  
## 액티비티 매니저 서비스의 startService() 메서드 호출 과정(바인더 RPC 활용)  
- startService() API가 실제 안드로이드 프레임워크에서 어떻게 처리되는가  
- startService() API: 액티비티에서 호출, 액티비티 매니저 서비스에게 서비스 생성 및 실행과 관련된 내용을 요청  
- 액티비티 매니저 서비스에 속한 startService() 스텁 메서드: 실제 구현  
=> startService() API는 자바 서비스 프레임워크 기반에서 바인더 RPC 형태로 액티비티 매니저 서비스에서 제공하는 startService() 스텁 메서드를 호출  
- 위의 (1)번 과정 구체화  
1. Controller Activity - ActivityManagerProxy 객체의 startService() proxy method 호출  
2. ActivityManagerProxy 객체 - 자바 서비스 프레임워크를 통해 ActivityManagerNative 객체에 START_SERVICE_TRANSACTION RPC 코드와 바인더 RPC 데이터를 전송  
3. ActivityManagerNative 객체 - ActivityManagerService에 포함된 startService() 스텁 메서드를 호출  
- 주요 소스 코드의 흐름  
### (1) Controller 액티비티
(a) ContextWrapper 클래스 - ContextImpl 객체의 startService() 메서드 호출  
- 액티비티에서 startService() API 호출 -> Activity 클래스가 상속하는 ContextWrapper 클래스의 startService()가 호출  
- ContextWrapper: Context 추상 클래스를 확장한 클래스, 멤버 변수 mBase에 저장된 Context 객체를 wrapping하는 역할  
- ContextWrapper 객체는 Controller 액티비티의 ContextImpl 객체를 래핑  
=> ContextWrapper의 startService() 메서드는 결국 ContextImpl 객체의 startService를 호출한다.  
(b) ContextImpl 클래스 - startService() 메서드 처리  
- ContextImpl: Context 추상 클래스를 실제 구현한 클래스, 애플리케이션 자체의 리소스 접근, 액티비티나 애플리케이션 서비스 실행, 인텐트 송수신 등의 역할을 수행  
#### ActivityManagerNative.getDefault().startService() 처리 과정  
- ActivityManagerNative.getDefault() 함수는 결국 ActivityManagerProxy 객체를 반환, 이 객체는 액티비티 매니저 서비스가 제공하는 IActivityManager 서비스 인터페이스 기반의 메서드들을 바인더 RPC를 통해서 호출하는 역할을 한다.  
- ActivityManagerProxy의 startService()는 결국 ActivityManagerService의 startService() 스텁 메서드를 원격으로 호출하는 역할을 수행한다. 두 startService() 메서드는 동일한 함수 원형을 사용한다.  

### (2) ActivityManagerProxy 객체  
- ActivityManagerProxy 객체의 startService() 프록시 메서드가 처리하는 내용  
- ActivityManagerProxy 객체는 ActivityManagerNative 객체에 바인더 RPC 데이터를 전송하는 것이다.  

### (3) ActivityManagerNative 객체  
- 수신된 바인더 RPC 데이터는 ActivityManagerNative 객체의 onTransact() 메서드에서 처리  
- RPC 코드를 토대로 액티비티 매니저 서비스에서 호출할 스텁 메서드를 파악  
- onTransact() 메서드의 역할  
  - ActivityManagerProxy의 startService() 프록시 메서드의 인자 값이 마샬링된 data변수(Parcel 객체)를 바인더 RPC를 통해 수신한 다음, data 변수를 언마샬링하고 각 데이터를 별도의 변수에 저장한다.  
- 액티비티는 IActivityManager 서비스 인터페이스 기반의 바인더 RPC를 통해 액티비티 매니저 서비스에게 서비스 실행이나 인텐트 송수신 등의 기능 수행을 요청할 수 있다. 반대로 액티비티 매니저 서비스는 IApplicationThread 인터페이스 기반의 바인더 RPC를 통해 자신과 연결된 애플리케이션을 제어할 수 있다.  

=> Controller 액티비티가 RPC 메커니즘을 통해 액티비티 매니저 서비스의 startService() 스텁 메서드를 자신의 로컬 메서드인 것처럼 호출한 것으로 생각할 수 있다.  

## 액티비티 매니저 서비스 - startService() 스텁 메서드 실행  
- 액티비티 매니저 서비스가 요청받은 서비스를 어떻게 실행하는가: 액티비티 매니저 서비스가 startSerice()의 스텁 메서드를 어떻게 처리하는가    
- startService() 스텁 메서드는 startServiceLocked() 메서드를 호출  
- startServiceLocked() 메서드는 실행할 서비스와 관련된 ServiceRecord 값을 얻는다.  
(ServiceRecord는 안드로이드 애플리케이션 서비스에 대한 각종 정보가 담긴 클래스이다.)  
- 이를 위해 startServiceLocked() 메서드는 retrieveServiceLocked() 메서드에 인텐트를 전달해서 서비스에 대한 정보를 얻는다  
- ServiceRecord 객체를 bringUpServiceLocked() 메서드의 첫 번째 인자로 전달  
  - ServiceRecord 객체를 참조해서 해당 서비스가 실행될 프로세스 이름과 uid를 통해 ProcessRecord 객체가 이미 존자하는지 검색( getProcessRecordLocked() )  
  - ProcessRecord가 이미 존재하면 로컬 서비스의 경우와 같이 서비스가 실행될 프로세스가 이미 실행 중이므로 realStartServicLocked() 메서드를 통해 해당 프로세스와 동일한 영역 내에서 서비스를 실행시킨다.  
  - 액티비티 매니저 서비스가 추후에 새로 생성된 프로세스에게 RemoteService의 실행을 요청하기 위해 mPendingServices 배열에 ServiceRecord 객체를 저장, 이후 코드에서 Zygote에 의해 ActivityThread가 새로 생성된 후에 mPendingServices 배열에 저장해 놓은 ServiceRecord 객체를 통해 서비스를 실행할 수 있다.  
- ActivityManagerService 클래스 코드에는 두 개의 startProcessLocked() 메서드가 존재  
(1) 7개 인자 가짐: 리모트 서비스를 실행하기 위해 새로 생성할 프로세스 정보를 포함하는 ProcessRecord 객체를 만들고, 이를 mProcessNames 큐에 삽입, 성공적으로 끝나면 두 번째 startProcessLocked() 메서드를 호출  
(2) Process 클래스의 start() 메서드를 통해 Zygote에게 android.app.ActivityThread 프로세스 생성을 요청, Zygote에 의해 생성된 프로세스의 pid와 ProcessRecord 객체를 mPidsSelfLocked 해시에 키/값 쌍으로 저장, 액티비티 매니저 서비스는 pid 값을 통해 이와 관련된 ProcessRecord 객체 값을 해시를 통해 얻을 수 있다.  

## ActivityThread 클래스의 main() 메서드 실행  
- Zygote가 서비스 실행을 위해 액티비티 매니저 서비스가 요청한 ActivityThread 클래스를 새로운 프로세스 상에서 어떻게 실행하는가  
- ActivityThread 실행을 요청받은 Zygote는 새로 생성한 프로세스에 ActivityThread 클래스를 로드한 다음, ActivityThread 클래스의 main() 메서드를 호출한다.  
- ActivityThread 클래스에 포함된 main() 메서드  
  - 동일한 프로세스 내의 스레드 간 메시지 통신을 위해 Looper.prepareMainLooper() 메서드를 이용해서 메시지 큐를 생성  
- ActivityThread가 생성되고 나면 이 객체의 attach() 메서드가 호출, attach() 메서드의 실질적인 처리는 attachApplication() 스텁 메서드가 담당  
- ActivityThread는 attach() 메서드를 처리하기 위해 바인더 RPC를 이용해서 액티비티 매니저 서비스가 제공하는 attachApplication() 스텁 메서드를 호출해야 한다. ActivityThread 객체는 ActivityManagerProxy를 생성한 다음 바인더 RPC를 통해 액티비티 매니저 서비스에 접근해야한다. (ActivityManagerProxy 객체는 액티비티가 액티비티 매니저 서비스에게 특정 기능을 요청할 때 사용)  
1. ActiviyThread - ActivityManagerProxy 객체의 attachApplication() 프록시 메서드를 호출  
2. ActivityManaterProxy 객체 - ActivityManagerNative 객체에 ATTACH_APPLICATION_TRANSACTION RPC 코드와 바인더 RPC 데이터를 전송  
3. ActivityManagerNative 객체 - ActiviyManagerService에 포함된 attachApplication() 스텁 메서드 호출  

=> 이 절의 목적은 ActivityThread와 액티비티 매니저 서비스 간의 상호작용을 위한 바인더 연결을 설정하는 것  

(1) ActivityThread 객체  
- attach() 메서드: ActivityThread와 액티비티 매니저 서비스 간에 IActivityManager 인터페이스 기반의 바인더 RPC를 위한 연결을 설정한다  
- 바인더 RPC 연결이 설정되면 ActivityThread는 ActivityManagerProxy 객체를 통해 액티비티 매니저 서비스에게 특정 작업을 요청할 수 있다  
(2) ActivityManagerProxy 객체  
- ActivityManagerProxy 객체의 attachApplication() 프록시 메서드  
  - ApplicationThread에 대한 바인더 객체를 마샬링해서 RPC 코드와 바인더 RPC 데이터를 ActivityManageNative 객체에 전달한다.  
(3) ActivityManagerNative 객체  
- RPC 코드와 바인더 RPC 데이터는 ActivityManagerNative 객체의 onTransact() 메서드를 통해 처리된다  
- 액티비티 매니저 서비스가 ActivityThread와 IApplicationThread 인터페이스 기반의 바인더 RPC 통신을 실행할 수 있게 ApplicationThreadNative.asInterface() 메서드를 통해 ApplicationThreadProxy 객체를 생성한다.  

## 액티비티 매니저 서비스 - attachApplication() 스텁 메서드 처리  
- attachApplication() 스텁 메서드의 동작 과정(간단히)  
  - Controller 액티비티가 startService() API를 통해 실행을 요청한 애플리케이션 서비스 생성을 ActivityThread에 명령하는 역할을 수행  
  - Controller가 요청한 서비스의 실제 생성은 ActivityThread를 통해 이뤄지지만 이러한 작업을 제어하는 것은 액티비티 매니저 서비스의 attachApplication() 스텁 메서드이다  
  => 액티비티 매니저 서비스는 IApplicationThread 인터페이스 기반의 바인더 RPC를 이용해서 안드로이드 애플리케이션 컴포넌트인 액티비티, 서비스 등을 생성하고 생명주기를 제어한다.  
  
- 액티비티 매니저 서비스가 바인더 RPC를 통해 ActivityThread에게 생성할 서비스 정보를 넘겨 실제 RemoteService를 실행  
1. 액티비티 매니저 서비스 - ActivityManagerProxy 객체의 scheduleCreateService() 프록시 메서드 호출  
2. ActivityManagerProxy 객체 - ActivityThread의 ActivityManagerNative 객체에 SCHEDULE_CREATE_SERVICE_TRANSACTION RPC 코드와 바인더 RPC 데이터 전송  
3. ActivityManagerNative 객체 - ApplicationCreateService의 ApplicationThread 객체에 포함된 scheduleCreateService() 스텁 메서드 호출  
4. ApplicationThread 객체 - ApplicationCreateService의 ActivityThread에 메시지큐를 이용해 CREATE_SERVICE 메시지 전달  
5. ActivityThread 객체 - RemoteService 서비스 생성 및 서비스 생명주기에 따른 onCreate() 호출  

### (1) 액티비티 매니저 서비스 -scheduleCreateService() 프록시 메서드 호출  
- attachApplication() 스텁 메서드는 attachApplicationLocked() 메서드를 호출   
  - 인자로 ApplicationThreadProxy 객체와 attachApplication() 스텁 메서드를 호출한 프로세스의 pid를 갖는다  
- attachApplicationLocked() 메서드  
  - 해시 함수를 호출해서 ActivityThread pid를 키 값으로 대응하는 value 값인 ProcessRecord 객체를 얻는다  
  - 액티비티 매니저 서비스는 ApplicationThreadProxy 객체를 이용해서 이 객체와 연결된 ActivityThread를 제어할 수 있다.  
  - 액티비티 매니저 서비스는 안드로이드 시스템 내의 각종 ActivityThread 상에서 동작하는 애플리케이션 컴포넌트들을 제어해야하는 시스템 서비스이므로 제어하고자 하는 ActivityThread와 관련된 ApplicationThreadProxy 객체를 구하는 메커니즘이 필요, 프로세스의 각종 정보를 포함하는 ProcessRecord에 ApplicationThreadProxy 객체를 연결하면 액티비티 매니저 서비스는 제어하려는 애플리케이션의 pid를 구한 다음 이에 해당하는 ApplicationThreadProxy 객체를 구할 수 있다.  
- 액티비티 매니저 서비스가 요청된 애플리케이션 서비스를 실행하기 위해 서비스와 관련된 정보를 저장하는 ServiceRecord 구조체를 얻는 과정  
  - bringUpServiceLocked() 메서드에서는 액티비티 매니저 서비스가 실행할 서비스의 ServiceRecord 객체를 mPendingServices 큐에 저장, mPendingServices.get() 메서드를 이용해 큐에 저장했던 RemoteService에 대한 ServiceRecord 객체를 얻는다. 구한 ProcessRecord와 ServiceRecord 값을 realStartServiceLocked() 메서드로 전달  
  - app.thread.scheduleCreateService() 메서드 호출, app.thread에는 서비스 실행을 요청한 ActivityThread를 제어하기위한 ApplicationThreadProxy 객체가 저장돼 있다.  
  - ApplicationThreadProxy의 scheduleCreateService() 메서드를 호출하는데, 이때 실행할 서비스에 대한 정보가 포함된 ServiceRecord 객체 등이 인자로 전달  

### (2) ApplicationThreadProxy 객체 - 바인더 RPC 데이터 전송  
- 생성할 서비스에 대한 정보를 포함한 ServiceInfo 객체를 RPC 코드와 바인더 RPC 데이터를 통해 ApplicationThreadNative 객체에 전달  

### (3) ApplicationThreadNative 객체 - scheduleCreateService() 스텁 메서드 호출  
- 수신한 바인더 RPC 데이터를 onTransact() 메서드에서 처리  
- ServiceRecord 객체와 ServiceInfo 객체를 언마샬링한 다음 각각 token, info 변수에 저장하고 ActivityThread의 scheduleCreateService() 스텁 메서드의 인자로 넘긴다.  

### (4) ApplicationThread 객체 - ActivityThread로 CREATE_SERVICE 메시지 전달  
- scheduleCreateService() 스텁 메서드는 인자로 전달된 ServiceRecord와 ServiceInfo 객체를 이용해 CreateServiceData라는 객체를 만든 다음 이를 ActivityThread 메시지 큐에 CREATE_SERVICE 메시지로 전달  
  - ApplicationThread는 액티비티 매니저 서비스의 제어 명령을 바인더 RPC로 수신하기 위한 용도, 실제 액티비티 매니저 서비스로부터 요청받은 서비스를 실행하거나 생명주기를 관리하는 일은 ActivityThread가 처리. ApplicationThread와 ActivityThread의 경우 동일 프로세스 영역에서 동작하기 때문에 이 둘 사이의 통신은 메시키 큐가 사용  
  
### (5) ActivityThread 객체 - 서비스 생성 및 서비스의 onCreate() 메서드 호출  
- ActivityThread는 메시지 큐를 자체적으로 가지고 있고 ApplicationThread로부터 수신된 메시지는 handleMessage() 메시지 핸들러에서 처리된다.  
- 결국 ApplicationThread는 액티비티 매니저 서비스로부터 바인더 RPC 데이터를 통해 받은 명령을 메시지 큐를 통해 ActivityThread에 그대로 전달하는 역할을 한다.  

  
